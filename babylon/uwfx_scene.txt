 var scene = new BABYLON.Scene(engine);
    
      // setup fog in the scene
    scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
    scene.fogStart = 5;
    scene.fogEnd = 25;
    scene.fogColor = new BABYLON.Color3(0.1, 0.08, 0.25);
    scene.fogDensity = 0.1;

    // create a background cube
    let backgroundCube = BABYLON.MeshBuilder.CreateBox("background", { size: 60, sideOrientation: 2 }, scene);

    // setup the main camera for the scene and give it control limits
    let mainCam = new BABYLON.ArcRotateCamera("mainCam", BABYLON.Tools.ToRadians(100), BABYLON.Tools.ToRadians(85), 10, new BABYLON.Vector3(-0.25, 1, 0), scene);
    mainCam.layerMask = 1;
    mainCam.lowerRadiusLimit = 10;
    mainCam.upperRadiusLimit = 10;
    mainCam.lowerBetaLimit = BABYLON.Tools.ToRadians(85);
    mainCam.upperBetaLimit = BABYLON.Tools.ToRadians(85);

    mainCam.attachControl(canvas, true);

    // setup the camera that will "record" the caustics pattern
    let textureCamera = new BABYLON.ArcRotateCamera("textureCam", 0, 0, 190, new BABYLON.Vector3.Zero(), scene);
    textureCamera.layerMask = 2;
    textureCamera.mode = 1;
    textureCamera.orthoLeft = -7;
    textureCamera.orthoTop = 7;
    textureCamera.orthoRight = 7;
    textureCamera.orthoBottom = -7;

    // create a spotlight that will project the cuastics pattern as light
    let light = new BABYLON.SpotLight("spotLight", new BABYLON.Vector3(0, 30, 0), BABYLON.Vector3.Down(), BABYLON.Tools.ToRadians(50), 8, scene);

    // create a high resolution plane to function as the basis for the water caustics
    let waterPlane = new BABYLON.Mesh.CreateGround("waterPlane", 15, 15, 400, scene);
    waterPlane.layerMask = 2;

    // setup a render target texture from the view of the texture camera, recording the waterplane...also set the render target UVs to a higher resolution with a mirrored wrap mode
    let renderTarget = new BABYLON.RenderTargetTexture("RTT", 1024, scene);
    renderTarget.activeCamera = textureCamera;
    scene.customRenderTargets.push(renderTarget);
    renderTarget.renderList.push(waterPlane);
    renderTarget.wrapU = BABYLON.Constants.TEXTURE_MIRROR_ADDRESSMODE;
    renderTarget.wrapV = BABYLON.Constants.TEXTURE_MIRROR_ADDRESSMODE;
    renderTarget.uScale = 2;
    renderTarget.vScale = 2;

    // instruct the spotlight to project the rendered target texture as a light projection
    light.projectionTexture = renderTarget;

    // load the waterShader from a URL snippet and assign it to the high res water plane
    BABYLON.NodeMaterial.ParseFromSnippetAsync("7X2PUH", scene).then(nodeMaterial => {
        nodeMaterial.name = "causticMaterial";
        waterPlane.material = nodeMaterial;
    });

    // setup the "god rays"
    // particle system variables
    let volumetricEmitter = new BABYLON.AbstractMesh("volumetricEmitter", scene);

    // set up animation sheet
    let setupAnimationSheet = function (system, texture, width, height, numSpritesWidth, numSpritesHeight, animationSpeed, isRandom) {
        // assign animation parameters
        system.isAnimationSheetEnabled = true;
        system.particleTexture = new BABYLON.Texture(texture, scene, false, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);
        system.particleTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
        system.particleTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
        system.spriteCellWidth = width / numSpritesWidth;
        system.spriteCellHeight = height / numSpritesHeight;
        let numberCells = numSpritesWidth * numSpritesHeight;
        system.startSpriteCellID = 0;
        system.endSpriteCellID = numberCells - 1;
        system.spriteCellChangeSpeed = animationSpeed;
        system.spriteRandomStartCell = isRandom;
        system.updateSpeed = 1 / 30;
    };

    // particle system
    let volumetricSystem = new BABYLON.ParticleSystem("volumetricSystem", 100, scene, null, true);
    setupAnimationSheet(volumetricSystem, "https://models.babylonjs.com/Demos/UnderWaterScene/godRays/volumetricLight.png", 1024, 1024, 4, 1, 0, true);
    volumetricSystem.emitter = volumetricEmitter.position;
    let boxEmitter = volumetricSystem.createBoxEmitter(new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(-5, 5, -3), new BABYLON.Vector3(5, 5, 3));
    boxEmitter.radiusRange = 0;
    volumetricSystem.minInitialRotation = 0;
    volumetricSystem.maxInitialRotation = 0;
    volumetricSystem.minScaleX = 6;
    volumetricSystem.maxScaleX = 10;
    volumetricSystem.minScaleY = 30;
    volumetricSystem.maxScaleY = 50;
    volumetricSystem.minLifeTime = 6;
    volumetricSystem.maxLifeTime = 9;
    volumetricSystem.emitRate = 15;
    volumetricSystem.minEmitPower = 0.05;
    volumetricSystem.maxEmitPower = 0.1;
    volumetricSystem.minSize = 0.1;
    volumetricSystem.maxSize = 0.2;
    volumetricSystem.addColorGradient(0, new BABYLON.Color4(0, 0, 0, 0));
    volumetricSystem.addColorGradient(0.5, new BABYLON.Color4(0.25, 0.25, 0.3, 0.2));
    volumetricSystem.addColorGradient(1.0, new BABYLON.Color4(0, 0, 0, 0));
    volumetricSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
    volumetricSystem.start();

    // add a blur effect to the caustics material.
    let blurAmount = 70;
    let standardPipeline = new BABYLON.PostProcessRenderPipeline(engine, "standardPipeline");
    let horizontalBlur = new BABYLON.BlurPostProcess("horizontalBlur", new BABYLON.Vector2(1.0, 0), blurAmount, 1.0, null, null, engine, false);
    let verticalBlur = new BABYLON.BlurPostProcess("verticalBlur", new BABYLON.Vector2(0, 1), blurAmount, 1.0, null, null, engine, false);
    let blackAndWhiteThenBlur = new BABYLON.PostProcessRenderEffect(engine, "blackAndWhiteThenBlur", function () { return [horizontalBlur, verticalBlur] });
    standardPipeline.addEffect(blackAndWhiteThenBlur);
    scene.postProcessRenderPipelineManager.addPipeline(standardPipeline);
    scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline("standardPipeline", textureCamera);
