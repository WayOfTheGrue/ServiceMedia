uwVX =
`precision highp float;
//Attributes
attribute vec3 position;
attribute vec2 uv;	
attribute vec3 normal;
// Uniforms
uniform mat4 world;
uniform mat4 worldViewProjection;
uniform float time;

//Varyings
varying vec2 vUV;
varying vec2 tUV;
varying vec3 vNormal;
varying vec3 vPosition;

//Helpers
const float PI = 3.1415926535897932384626433832795;
const float LinearEncodePowerApprox = 2.2;
const float GammaEncodePowerApprox = 1.0 / LinearEncodePowerApprox;
const vec3 LuminanceEncodeApprox = vec3(0.2126, 0.7152, 0.0722);

mat3 transposeMat3(mat3 inMatrix) {
	vec3 i0 = inMatrix[0];
	vec3 i1 = inMatrix[1];
	vec3 i2 = inMatrix[2];

	mat3 outMatrix = mat3(
		vec3(i0.x, i1.x, i2.x),
		vec3(i0.y, i1.y, i2.y),
		vec3(i0.z, i1.z, i2.z)
		);

	return outMatrix;
}

// https://github.com/glslify/glsl-inverse/blob/master/index.glsl
mat3 inverseMat3(mat3 inMatrix) {
	float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];
  	float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];
  	float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];

  	float b01 = a22 * a11 - a12 * a21;
  	float b11 = -a22 * a10 + a12 * a20;
  	float b21 = a21 * a10 - a11 * a20;

  	float det = a00 * b01 + a01 * b11 + a02 * b21;

  	return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
}

float computeFallOff(float value, vec2 clipSpace, float frustumEdgeFalloff)
{
	float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(clipSpace, clipSpace), 0., 1.));
	return mix(value, 1.0, mask);
}

vec3 applyEaseInOut(vec3 x){
	return x * x * (3.0 - 2.0 * x);
}

vec3 toLinearSpace(vec3 color)
{
	return pow(color, vec3(LinearEncodePowerApprox));
}

vec3 toGammaSpace(vec3 color)
{
    return pow(color, vec3(GammaEncodePowerApprox));
}

float square(float value)
{
    return value * value;
}

float getLuminance(vec3 color)
{
    return clamp(dot(color, LuminanceEncodeApprox), 0., 1.);
}

// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float getRand(vec2 seed) {
	return fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float dither(vec2 seed, float varianceAmount) {
	float rand = getRand(seed);
	float dither = mix(-varianceAmount/255.0, varianceAmount/255.0, rand);
	
	return dither;
}


#if NUM_BONE_INFLUENCERS > 0
	uniform mat4 mBones[BonesPerMesh];

	attribute vec4 matricesIndices;
	attribute vec4 matricesWeights;
	#if NUM_BONE_INFLUENCERS > 4
		attribute vec4 matricesIndicesExtra;
		attribute vec4 matricesWeightsExtra;
	#endif
#endif

void main(void) {

    vec4 p = vec4( position, 1. );

    #if NUM_BONE_INFLUENCERS > 0
	mat4 influence;
	influence = mBones[int(matricesIndices[0])] * matricesWeights[0];

	#if NUM_BONE_INFLUENCERS > 1
		influence += mBones[int(matricesIndices[1])] * matricesWeights[1];
	#endif	
	#if NUM_BONE_INFLUENCERS > 2
		influence += mBones[int(matricesIndices[2])] * matricesWeights[2];
	#endif	
	#if NUM_BONE_INFLUENCERS > 3
		influence += mBones[int(matricesIndices[3])] * matricesWeights[3];
	#endif	

	#if NUM_BONE_INFLUENCERS > 4
		influence += mBones[int(matricesIndicesExtra[0])] * matricesWeightsExtra[0];
	#endif	
	#if NUM_BONE_INFLUENCERS > 5
		influence += mBones[int(matricesIndicesExtra[1])] * matricesWeightsExtra[1];
	#endif	
	#if NUM_BONE_INFLUENCERS > 6
		influence += mBones[int(matricesIndicesExtra[2])] * matricesWeightsExtra[2];
	#endif	
	#if NUM_BONE_INFLUENCERS > 7
		influence += mBones[int(matricesIndicesExtra[3])] * matricesWeightsExtra[3];
	#endif	

	p = p * influence;
    #endif

    
    gl_Position = worldViewProjection * p;
    vUV = uv;
	tUV = uv*2.0-1.0;
    vNormal = normal;
    vPosition = vec3(world * vec4(position, 1.0));
}`;

uwFX =
`precision highp float;
//Varyings
varying vec2 vUV;
varying vec2 tUV;
varying vec3 vNormal;
varying vec3 vPosition;

//Default Uniforms
uniform float time;
uniform mat4 world;
uniform sampler2D textureSampler;
uniform vec3 cameraPosition;

#define TAU 6.28318530718
#define MAX_ITER 4

vec3 caustic(vec2 uv)
{
    vec2 p = mod(uv*TAU, TAU)-250.0;
    float tTime = time * .5+23.0;

	vec2 i = vec2(p);

	float c = 1.0;
	float inten = .005;

	for (int n = 0; n < MAX_ITER; n++) 
	{
		float t = tTime * (1.0 - (3.5 / float(n+1)));
		i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
		c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));
	}
    
	c /= float(MAX_ITER);
	c = 1.17-pow(c, 1.4);
	vec3 color = vec3(pow(abs(c), 8.0));
    color = clamp(color + vec3(0.0, 0.35, 0.5), 0.0, 1.0);
    color = mix(color, vec3(1.0,1.0,1.0),0.3);
    
    return color;
}

	
void main(void) {
    vec3 vLightPosition = vec3(0., 100., 0.);
    vec3 baseColor = vec3(0.1, 0.1, 0.15);

    vec3 vPositionW = vec3(world * vec4(vPosition, 1.0));
    vec2 pos = vPositionW.xz/6.;

    vec3 vNormalW = normalize(vec3(world * vec4(vNormal, 0.0)));
    
    vec3 viewDirectionW = normalize(cameraPosition - vPositionW);

    vec3 lightVectorW = normalize(vLightPosition - vPositionW);
    vec3 color = baseColor;

    float ndl = max(0., dot(vNormalW, lightVectorW));


    vec3 angleW = normalize(viewDirectionW + lightVectorW);
    float specComp = max(0., dot(vNormalW, angleW));
    specComp = pow(specComp, max(1., 64.)) * 0.5;
    
    color = mix(caustic(pos), color, 1.0-ndl);
    
    

    gl_FragColor = vec4(color, 1.0);
}`;

uwBGpost =
`precision highp float;
//Varyings
varying vec2 vUV;


//Default Uniforms
uniform float time;
uniform sampler2D textureSampler;
uniform sampler2D dPass;
uniform vec2 screenSize;

#define TAU 6.28318530718
#define MAX_ITER 8
#define BASE_INTEN .005

float causticX(float x, float power, float gtime)
{
    float p = mod(x*TAU, TAU)-250.0;
    float tTime = gtime * .5+23.0;

	float i = p;
	float c = 1.0;
	float inten = BASE_INTEN;

	for (int n = 0; n < MAX_ITER/2; n++) 
	{
		float t = tTime * (1.0 - (3.5 / float(n+1)));
		i = p + cos(t - i) + sin(t + i);
		c += 1.0/length(p / (sin(i+t)/inten));
	}
	c /= float(MAX_ITER);
	c = 1.17-pow(c, power);
    
    return c;
}

float GodRays(vec2 uv)
{
    float light = 0.0;

    light += pow(causticX((uv.x+0.08*uv.y)/1.7+0.5, 1.8, time*0.65),10.0)*0.05;
    light-=pow((1.0-uv.y)*0.3,2.0)*0.2;
    light += pow(causticX(sin(uv.x), 0.3,time*0.7),9.0)*0.4; 
    light += pow(causticX(cos(uv.x*2.3), 0.3,time*1.3),4.0)*0.1;  
        
    light-=pow((1.0-uv.y)*0.3,3.0);
    light=clamp(light,0.0,1.0);
    
    return light;
}

float hash( float n )
{
    return fract(sin(n)*43758.5453123);
}

float Bubble(vec2 loc, vec2 pos, float size)
{
	vec2 v2 = loc-pos;
	float d = dot(v2, v2)/size;
	if (d > 1.0) return pow(max(0.0,1.5-d), 3.0) *5.0;
	d = pow(d, 6.0)*.85;
	
	// Top bright spot...
	v2 = loc-pos+vec2(-size*7.0, +size*7.0);
	d += .8 / max(sqrt((dot(v2, v2))/size*8.0), .3);
	// Back spot...
	v2 = loc-pos+vec2(+size*7.0, -size*7.0);
	d += .2 / max((dot(v2, v2)/size*4.0), .3);
	return d;
}
	
void main(void) {
    vec3 skyColor = vec3(0.3, 1.0, 1.0);
    vec2 p = vUV*(screenSize.y/screenSize.x);
        
    vec3 color = texture2D(textureSampler, vUV).rgb;
    
    float dVal = texture2D(dPass, vUV).r;
    if(dVal < 1.0){
        dVal = 0.0;
    }

/*
    // Bubbles...
	for (float i = 0.0; i < 5.0; i+=1.0)
	{
		float t = time*0.5+5.27;
		float f = floor((t+2.0) / 4.0);
		vec2 pos = vec2(.4, -.9) + vec2(0.0, mod(t+(i/50.0)+hash(i+f)*.7, 4.0));
		pos.x += hash(i)*.7 * (p.y+.6);
		
		//pos += texture(textureSampler, (p*.3-time*.1+(i/80.0)), 4.0).z * .05;
		float d = Bubble(pos, p, .002*hash(i-f)+.00015);
		d *= hash(i+f+399.0) *.3+.08;
		color = mix(color, vec3(.6+hash(f*323.1+i)*.4, 1.0, 1.0), d);
	}
*/

    vec3 light = 
    ((GodRays(p*0.5)*mix(float(skyColor),1.0,p.y*p.y)*vec3(0.7,1.0,1.0))*dVal)+
    (GodRays(p*2.)*mix(float(skyColor),1.0,p.y*p.y)*vec3(0.7,1.0,1.0));

    color += light*p.y;
    
    
    gl_FragColor = vec4(color, 1.0);
}`;


BABYLON.Effect.ShadersStore['underWaterVertexShader'] = uwVX;
BABYLON.Effect.ShadersStore['underWaterFragmentShader'] = uwFX;
BABYLON.Effect.ShadersStore['underWaterBackGroundFragmentShader'] = uwBGpost;